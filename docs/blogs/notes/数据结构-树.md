# 数据结构:树

## 什么是树

> 树是一种数据结构，它是由n(n>=1)个有限结点组成一个具有层次关系的集合。

图例：

![Linux目录结构](/images/notes/数据结构-树/Linux目录结构.jpg)

![人类族谱](/images/notes/数据结构-树/人类族谱.jpg)


> 分层次组织在管理上具有更高的效率。

## 如何实现有效率的查找？

**查找：**根据某个给定**关键字K**，从**集合R**中找出与**K**相同的记录。

- **静态查找：**集合中**记录是固定**的。

  - 没有插入和删除的操作，只有查找。

- **动态查找：**集合中**记录是动态变化**的。

  - 除了查找，还可能发生插入和删除。



### 引子：顺序查找和二分查找。

- 顺序查找：略。时间复杂度为 O(n)
- [二分查找](https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE)：时间复杂度为 O(logN)

假设待查找的元素队列为：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]

二分查找的顺序为：[6, 3, 1, 2] / [6, 3, 4, 5] / [6, 9, 7, 8] / [6, 9, 10, 11]

以上4种查找方案能查找出所有元素，最大查找次数为4次。用树的形式来展示：

![二分查找判定树](/images/notes/数据结构-树/二分查找判定树.jpg)

## 树的表示

![树的表示](/images/notes/数据结构-树/树的表示.jpg)

### 树的一些基本术语

1. 结点的度（Degree）：结点的**子树个数**
2. 树的度：树的所有结点中最大的度数
3. 叶结点（Leaf）：**度为0**的结点
4. 父节点（Parent）：有子树的结点就是其子树的父节点。例如：A是B的父节点（树1）。
5. 子节点（Child）：例如：B是A的子节点（树1）。
6. 兄弟结点（Sibling）：具有同一父节点的节点彼此是兄弟结点。例如：B的兄弟结点是C和D。
7. 路径和路径长度：例如：A->K的路径，路径长度为3。
8. 祖先结点（Ancestor）：沿**树根到某节点路径上的所有结点**都是该结点的祖先结点。
9. 子孙结点（Descendant）：某结点的**子树中所有结点**都是该结点的子孙结点。
10. 结点的层次（Level）：规定**根节点在1层**，其他任意一结点的层数是其父节点的层数加1。
11. 树的深度（Depth）：树中所有结点中的**最大层次**就是这棵树的深度。

### 儿子-兄弟表示法

由上图树2可以看出，每个结点的形式并不相同。结点的子节点数有0至3个不等，这对程序访问并不友好。如果将所有结点的子节点树统一为3（树的所有节点中最大的子节点树）个，则会造成空间浪费。儿子-兄弟表示法可以完美的解决这个问题。

![儿子-兄弟表示法](/images/notes/数据结构-树/儿子-兄弟表示法.jpg)

如上图，处理后旋转一下角度不难看出形成了一颗**二叉树**。

## 二叉树的定义

> **二叉树（T）：**一个有穷的结点集合。这个集合**可以为空**，若不为空，则它是由**根结点**和称为其**左子树T<sub>L</sub>**和**右子树T<sub>R</sub>**的两个不相交的二叉树组成。

- 二叉树具有五种基本形态：
  - Φ
  - T
  - T, T<sub>L</sub>
  - T, T<sub>R</sub>
  - T, T<sub>L</sub>, T<sub>R</sub>
- 二叉树的**子树有左右顺序之分**(T<sub>L</sub>/T<sub>R</sub>)

### 特殊二叉树

- 斜二叉树(Skewed Binary Tree)[skjuːd ˈbaɪnəri triː]：一边歪的二叉树。/  \
- 满二叉树(Full Binary Tree)：一棵深度为**k**且有**2<sup>k</sup>-1**个结点的二叉树称为满二叉树。
- 完美二叉树(Perfect Binary Tree)：同满二叉树。
- 完全二叉树(Complete Binary Tree)：有**n**个节点的二叉树，对树中的节点按从上到下、从左到右的顺序进行编号，编号为**i(1<=i<=n)**的结点与满二叉树中编号为**i**的结点在二叉树中位置相同。
  - 满二叉树由下到上、由右到左依次删除结点，每次删除结点后的二叉树就可以叫做完全二叉树。

### 二叉树几个重要性质

- 一个二叉树第**i**层的最大结点数为：**2<sup>i-1</sup>, i>=1**。
- 深度为**k**的二叉树有最大结点总数为：**2<sup>k-1</sup>, k>=1**。
- 对任何非空二叉树**T**，若**n<sub>0</sub>**表示叶节点的个数、**n<sub>2</sub>**是度为**2**的非叶结点个数，那么两者满足关系 **n<sub>0</sub> = n<sub>2</sub> + 1**。

### 【code】二叉树的抽象数据类型定义

- 类型名称：**二叉树**
- 数据对象集：一个有穷的结点集合。若不为空，则由**根结点和其左右二叉子树**组成。
- 操作集：**BT∈BinTree**, **Item∈ElementType**，重要操作有：
  - `def IsEmpty(BT: BinTree) -> bool:`：判别BT是否为空；
  - `def Traversal(BT: BinTree):`：遍历，按某顺序访问每个结点；
  - `def CreatBinTree() -> BinTree:`：创建一个二叉树。

---

**常用遍历方法：**

- `def PreOrderTraversal(BT: BinTree):`：先序 => 根、左子树、右子树；
- `def InOrderTraversal(BT: BinTree):`：中序 => 左子树、根、右子树；
- `def PostOrderTraversal(BT: BinTree):`：后序 => 左子树、右子树、根；
- `def LevelOrderTraversal(BT: BinTree):`：层次遍历 => 从上到下、从左到右；

## 二叉树的储存结构

1. 顺序储存结构

   - **完全二叉树：**按从上至下、从左到右顺序储存**n**个节点的完全二叉树的**结点父子关系**。

     ![完全二叉树顺序储存](/images/notes/数据结构-树/完全二叉树顺序储存.jpg)

   - **一般二叉树：**一般二叉树也可以采用上方结构，但会造成空间浪费。

     ![一般二叉树顺序储存](/images/notes/数据结构-树/一般二叉树顺序储存.jpg)

2. 链表存储

   ```python
   class TreeNode(object):
       
       Data = None
       Left: BinTree = None
       Right: Bintree = None
   ```

   ![链表储存](/images/notes/数据结构-树/链表储存.jpg)

## 【code】二叉树的遍历

1. **先序遍历**

   遍历过程：

   1. 访问**根结点**
   2. **先序**遍历其**左子树**
   3. **先序**遍历其**右子树**

   ```python
   def PreOrderTravelsal(BT: BinTree):
       if BT:
           print(f"{BT.Data}")				# 输出当前值
           PreOrderTraversal(BT.Left)		# 访问左结点
           PreOrderTraversal(BT.Right)		# 访问右结点
   ```

2. **中序遍历**

   遍历过程：

   1. **中序**遍历其**左子树**
   2. 访问根结点
   3. **中序**遍历其**右子树**

   ```python
   def InOrderTravelsal(BT: BinTree):
       if BT:
           PreOrderTraversal(BT.Left)		# 访问左结点
           print(f"{BT.Data}")				# 输出当前值
           PreOrderTraversal(BT.Right)		# 访问右结点
   ```

3. **后序遍历**

   遍历过程：

   1. **后序**遍历其**左子树**
   2. **后序**遍历其**右子树**
   3. 访问**根结点**

   ```python
   def PostOrderTravelsal(BT: BinTree):
       if BT:
           PreOrderTraversal(BT.Left)		# 访问左结点
           PreOrderTraversal(BT.Right)		# 访问右结点
           print(f"{BT.Data}")				# 输出当前值
   ```

先序、中序和后序遍历过程中经过结点的**路线一样**（绕着树从左往右画了一圈轮廓），只是**访问各节点的时机不同**。

4. **非递归遍历（先序、中序、后序）**

   利用堆栈，后进后出来实现。

   ```python
   def PreOrderTravelsal(BT: BinTree):
   	stack: Stack = CreatStack(maxSize)
       while BT or not IsEmpty(stack):
           while BT:
               print(BT.Data)			# 访问后压栈
               Push(stack, BT)
               BT = BT.left
           if not IsEmpty(stack):
               BT = Pop(stack)
               BT = BT.right
   
           
   def InOrderTraversal(BT: BinTree):
       stack: Stack = CreatStack(maxSize)
       while BT or not IsEmpty(stack):
           while BT:					# 只要有左节点，就压栈
               Push(stack, BT)
               BT = BT.Left
           if not IsEmpty(stack):
               BT = Pop(stack)			# 栈不为空，弹出栈顶结点
               print(BT.Data)			# 访问结点
               BT = BT.Right			# 转向右子树
               
               
   def PostOrderTraversal(BT: BinTree):
       stack: Stack = CreatStack(maxSize)
       while BT or not IsEmpty(stack):
           while BT:					# ...
               break
           break
   ```

5. **层序遍历**

