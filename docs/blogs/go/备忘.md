### 起步阶段

```shell
# 安装扩展   
go env -w GOPROXY=https://goproxy.cn

# vscode:  go: cannot find main module
go env -w GO111MODULE=off
```

常量、关键字
```text
break      default       func     interface   select
case       defer         go       map         struct
chan       else          goto     package     switch
const      fallthrough   if       range       type
continue   for           import   return      var

内建常量: true false iota nil

内建类型: int int8 int16 int32 int64
          uint uint8 uint16 uint32 uint64 uintptr
          float32 float64 complex128 complex64
          bool byte rune string error

内建函数: make len cap new append copy close delete
          complex real imag
          panic recover
```

关于算术运算、逻辑运算和比较运算的二元运算符，它们按照先级递减的顺序的排列：
```text
*      /      %      <<       >>     &       &^
+      -      |      ^
==     !=     <      <=       >      >=
&&
||
```

正无穷和负无穷：
```go
var z float64
fmt.Println(z, -z, 1/z, -1/z, z/z) // "0 -0 +Inf -Inf NaN"
```


### Print

- `Printf`: `print format`
- `Println`: `print line`

```
%d          十进制整数
%x, %o, %b  十六进制，八进制，二进制整数。
%f, %g, %e  浮点数： 3.141593 3.141592653589793 3.141593e+00
%t          布尔：true或false
%c          字符（rune） (Unicode码点)
%s          字符串
%q          带双引号的字符串"abc"或带单引号的字符'c'
%v          变量的自然形式（natural format）
%T          变量的类型
%%          字面上的百分号标志（无操作数）
```

当使用fmt包打印一个数值时，我们可以用%d、%o或%x参数控制输出的进制格式:
```go
o := 0666
fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"
x := int64(0xdeadbeef)
fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)
// Output:
// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
```
**通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的[1]副词告诉Printf函数再次使用第一个操作数。第二，%后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。**

`io.Copy(dst, src)`


### 操作符号

- `<-`

  goroutine是golang中在语言级别实现的轻量级线程，仅仅利用`go function`就能立刻起一个新线程。多线程会引入线程之间的同步问题，在golang中可以使用channel作为同步的工具。

  通过channel可以实现两个goroutine之间的通信。创建一个channel，`make(chan TYPE {, NUM})`, TYPE指的是channel中传输的数据类型，第二个参数是可选的，指的是channel的容量大小。chan类型类似于一个数组。

  **向channel传入数据**， CHAN <- DATA , CHAN 指的是目的channel即收集数据的一方， DATA 则是要传的数据。

  **从channel读取数据**， DATA := <-CHAN ，和向channel传入数据相反，在数据输送箭头的右侧的是channel，形象地展现了数据从‘隧道’流出到变量里。

  [实例](<https://yar999.gitbook.io/gopl-zh/ch1/ch1-06>)

- `&  *`

  **指针：**Go语言提供了指针。指针是一种直接存储了变量的内存地址的数据类型。在其它语言中，比如C语言，指针操作是完全不受约束的。在另外一些语言中，指针一般被处理为“引用”，除了到处传递这些指针之外，并不能对这些指针做太多事情。Go语言在这两种范围中取了一种平衡。指针是可见的内存地址，&操作符可以返回一个变量的内存地址，并且*操作符可以获取指针指向的变量内容，但是在Go语言里没有指针运算，也就是不能像c语言里可以对指针进行加或减操作。


### 类型声明、转换

```go
// Package tempconv performs Celsius and Fahrenheit temperature computations.
package tempconv

import "fmt"

type Celsius float64    // 摄氏温度
type Fahrenheit float64 // 华氏温度

const (
    AbsoluteZeroC Celsius = -273.15 // 绝对零度
    FreezingC     Celsius = 0       // 结冰点温度
    BoilingC      Celsius = 100     // 沸水温度
)

// 函数名(传参 参数类型) 返回值类型            类型转换(返回值)
func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }

func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }

// Celsius类型的参数c出现在了函数名的前面，表示声明的是Celsius类型的一个叫名叫String的方法，该方法返回该类型对象c带着°C温度单位的字符串
func (c Celsius) String() string { return fmt.Sprintf("%g°C", c) }
/* exp: 
c := 100
fmt.Printf("%s", c.String())    // 100°C
*/
```

